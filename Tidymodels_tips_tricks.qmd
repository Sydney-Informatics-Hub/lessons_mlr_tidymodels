## use\_\*()

The [usemodels package](https://usemodels.tidymodels.org) is a helpful way of quickly creating code snippets to fit models using the tidymodels framework. Given a simple formula and a data set, the use\_\* functions can create code that appropriate for the data (given the model). The package includes these templates:

```{r}
library(usemodels)
ls("package:usemodels", pattern = "use_")
```

```{r}
library(mlbench)
data(PimaIndiansDiabetes)
use_ranger(diabetes ~ ., data = PimaIndiansDiabetes)
```

## tune_race_anova()

The problem with grid search is that you don't know if some of those choices you made about the candidate parameters are any good until you're done with all the computations. The `tune_race_anova()` function is a dynamic way of doing grid search. What racing does is as you start to do the model tuning, it looks at the results as they happen and eliminates tuning parameter combinations that are unlikely to be the best results using a repeated measure ANOVA model:

```         
rf_tune_wf <- rf_workflow %>%
              tune_race_anova(resamples = diabetes_folds,
                              grid = rf_grid)
```

## step_mutate()

`step_mutate()` creates a specification of a recipe step that will add variables using `dplyr::mutate()`. We did this step during EDA in [Session 1](001_Regression/step1.qmd) but we could have easily introduced it in our recipe `ames_rec` object in this way:

```         
ames_rec <- recipe(Sale_Price ~ ., data = ames_train) %>% 
            step_mutate(Time_Since_Remodel = Year_Sold - Year_Remod_Add, 
                        House_Age = Year_Sold - Year_Built)
```

The advantage of performing these preprocessing steps with the recipe package is that all the feature engineering you want to perform to your data can be put into a single object, you can save that object, you can carry it around. It's not in a bunch of scripts. It's been unit tested and it has a lot of features in it.
